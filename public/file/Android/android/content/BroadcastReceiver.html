<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_20) on Thu Oct 14 17:32:04 CST 2010 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
BroadcastReceiver (Test API)
</TITLE>

<META NAME="date" CONTENT="2010-10-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="BroadcastReceiver (Test API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BroadcastReceiver.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../android/content/AsyncQueryHandler.html" title="android.content 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../android/content/ComponentCallbacks.html" title="android.content 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?android/content/BroadcastReceiver.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="BroadcastReceiver.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
android.content</FONT>
<BR>
类 BroadcastReceiver</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>android.content.BroadcastReceiver</B>
</PRE>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../android/appwidget/AppWidgetProvider.html" title="android.appwidget 中的类">AppWidgetProvider</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.162"><B>BroadcastReceiver</B></A><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
Base class for code that will receive intents sent by sendBroadcast().
 You can either dynamically register an instance of this class with
 <A HREF="../../android/content/Context.html#registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter)"><CODE>Context.registerReceiver()</CODE></A>
 or statically publish an implementation through the
 <CODE>&lt;receiver&gt;</CODE>
 tag in your <code>AndroidManifest.xml</code>. <em><strong>Note:</strong></em>
 &nbsp;&nbsp;&nbsp;If registering a receiver in your
 <A HREF="../../android/app/Activity.html#onResume()"><CODE>Activity.onResume()</CODE></A>
 implementation, you should unregister it in 
 <A HREF="../../android/app/Activity.html#onPause()"><CODE>Activity.onPause()</CODE></A>.
 (You won't receive intents when paused, 
 and this will cut down on unnecessary system overhead). Do not unregister in 
 <A HREF="../../android/app/Activity.html#onSaveInstanceState(android.os.Bundle)"><CODE>Activity.onSaveInstanceState()</CODE></A>,
 because this won't be called if the user moves back in the history
 stack.
 
 <p>There are two major classes of broadcasts that can be received:</p>
 <ul>
 <li> <b>Normal broadcasts</b> (sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A>) are completely asynchronous.  All receivers of the
 broadcast are run in an undefined order, often at the same time.  This is
 more efficient, but means that receivers cannot use the result or abort
 APIs included here.
 <li> <b>Ordered broadcasts</b> (sent with <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>) are delivered to one receiver at a time.
 As each receiver executes in turn, it can propagate a result to the next
 receiver, or it can completely abort the broadcast so that it won't be passed
 to other receivers.  The order receivers run in can be controlled with the
 <CODE>android:priority</CODE> attribute of the matching intent-filter; receivers with
 the same priority will be run in an arbitrary order.
 </ul>
 
 <p>Even in the case of normal broadcasts, the system may in some
 situations revert to delivering the broadcast one receiver at a time.  In
 particular, for receivers that may require the creation of a process, only
 one will be run at a time to avoid overloading the system with new processes.
 In this situation, however, the non-ordered semantics hold: these receivers still
 cannot return results or abort their broadcast.</p>
 
 <p>Note that, although the Intent class is used for sending and receiving
 these broadcasts, the Intent broadcast mechanism here is completely separate
 from Intents that are used to start Activities with
 <A HREF="../../android/content/Context.html#startActivity(android.content.Intent)"><CODE>Context.startActivity()</CODE></A>.
 There is no way for a BroadcastReceiver
 to see or capture Intents used with startActivity(); likewise, when
 you broadcast an Intent, you will never find or start an Activity.
 These two operations are semantically very different: starting an
 Activity with an Intent is a foreground operation that modifies what the
 user is currently interacting with; broadcasting an Intent is a background
 operation that the user is not normally aware of.
 
 <p>The BroadcastReceiver class (when launched as a component through
 a manifest's <CODE>&lt;receiver&gt;</CODE>
 tag) is an important part of an
 <a href="../..guide/topics/fundamentals.html#lcycles">application's overall lifecycle</a>.</p>
 
 <p>Topics covered here:
 <ol>
 <li><a href="#ReceiverLifecycle">Receiver Lifecycle</a>
 <li><a href="#Permissions">Permissions</a>
 <li><a href="#ProcessLifecycle">Process Lifecycle</a>
 </ol>
 
 <a name="ReceiverLifecycle"></a>
 <h3>Receiver Lifecycle</h3>
 
 <p>A BroadcastReceiver object is only valid for the duration of the call
 to <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(android.content.Context, android.content.Intent)</CODE></A>.  Once your code returns from this function,
 the system considers the object to be finished and no longer active.
 
 <p>This has important repercussions to what you can do in an
 <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(android.content.Context, android.content.Intent)</CODE></A> implementation: anything that requires asynchronous
 operation is not available, because you will need to return from the
 function to handle the asynchronous operation, but at that point the
 BroadcastReceiver is no longer active and thus the system is free to kill
 its process before the asynchronous operation completes.
 
 <p>In particular, you may <i>not</i> show a dialog or bind to a service from
 within a BroadcastReceiver.  For the former, you should instead use the
 <A HREF="../../android/app/NotificationManager.html" title="android.app 中的类"><CODE>NotificationManager</CODE></A> API.  For the latter, you can
 use <A HREF="../../android/content/Context.html#startService(android.content.Intent)"><CODE>Context.startService()</CODE></A> to
 send a command to the service.
 
 <a name="Permissions"></a>
 <h3>Permissions</h3>
 
 <p>Access permissions can be enforced by either the sender or receiver
 of an Intent.
 
 <p>To enforce a permission when sending, you supply a non-null
 <var>permission</var> argument to
 <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendBroadcast(Intent, String)</CODE></A> or
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)"><CODE>Context.sendOrderedBroadcast(Intent, String, BroadcastReceiver, android.os.Handler, int, String, Bundle)</CODE></A>.
 Only receivers who have been granted this permission
 (by requesting it with the
 <CODE>&lt;uses-permission&gt;</CODE>
 tag in their <code>AndroidManifest.xml</code>) will be able to receive
 the broadcast.
 
 <p>To enforce a permission when receiving, you supply a non-null
 <var>permission</var> when registering your receiver -- either when calling
 <A HREF="../../android/content/Context.html#registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter, java.lang.String, android.os.Handler)"><CODE>Context.registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)</CODE></A>
 or in the static
 <CODE>&lt;receiver&gt;</CODE>
 tag in your <code>AndroidManifest.xml</code>.  Only broadcasters who have
 been granted this permission (by requesting it with the
 <CODE>&lt;uses-permission&gt;</CODE>
 tag in their <code>AndroidManifest.xml</code>) will be able to send an
 Intent to the receiver.
 
 <p>See the <a href="../..guide/topics/security/security.html">Security and Permissions</a>
 document for more information on permissions and security in general.
 
 <a name="ProcessLifecycle"></a>
 <h3>Process Lifecycle</h3>
 
 <p>A process that is currently executing a BroadcastReceiver (that is,
 currently running the code in its <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(android.content.Context, android.content.Intent)</CODE></A> method) is
 considered to be a foreground process and will be kept running by the
 system except under cases of extreme memory pressure.
 
 <p>Once you return from onReceive(), the BroadcastReceiver is no longer
 active, and its hosting process is only as important as any other application
 components that are running in it.  This is especially important because if
 that process was only hosting the BroadcastReceiver (a common case for
 applications that the user has never or not recently interacted with), then
 upon returning from onReceive() the system will consider its process
 to be empty and aggressively kill it so that resources are available for other
 more important processes.
 
 <p>This means that for longer-running operations you will often use
 a <A HREF="../../android/app/Service.html" title="android.app 中的类"><CODE>Service</CODE></A> in conjunction with a BroadcastReceiver to keep
 the containing process active for the entire time of your operation.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#BroadcastReceiver()">BroadcastReceiver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#abortBroadcast()">abortBroadcast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the flag indicating that this receiver should abort the
 current broadcast; only works with broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#clearAbortBroadcast()">clearAbortBroadcast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the flag indicating that this receiver should abort the current
 broadcast.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#getAbortBroadcast()">getAbortBroadcast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the flag indicating whether or not this receiver should
 abort the current broadcast.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#getDebugUnregister()">getDebugUnregister</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the last value given to <A HREF="../../android/content/BroadcastReceiver.html#setDebugUnregister(boolean)"><CODE>setDebugUnregister(boolean)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#getResultCode()">getResultCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the current result code, as set by the previous receiver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#getResultData()">getResultData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the current result data, as set by the previous receiver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#getResultExtras(boolean)">getResultExtras</A></B>(boolean&nbsp;makeMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the current result extra data, as set by the previous receiver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)">onReceive</A></B>(<A HREF="../../android/content/Context.html" title="android.content 中的类">Context</A>&nbsp;context,
                   <A HREF="../../android/content/Intent.html" title="android.content 中的类">Intent</A>&nbsp;intent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is called when the BroadcastReceiver is receiving an Intent
 broadcast.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../android/os/IBinder.html" title="android.os 中的接口">IBinder</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#peekService(android.content.Context, android.content.Intent)">peekService</A></B>(<A HREF="../../android/content/Context.html" title="android.content 中的类">Context</A>&nbsp;myContext,
                       <A HREF="../../android/content/Intent.html" title="android.content 中的类">Intent</A>&nbsp;service)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provide a binder to an already-running service.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setDebugUnregister(boolean)">setDebugUnregister</A></B>(boolean&nbsp;debug)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control inclusion of debugging help for mismatched
 calls to .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setOrderedHint(boolean)">setOrderedHint</A></B>(boolean&nbsp;isOrdered)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For internal use, sets the hint about whether this BroadcastReceiver is
 running in ordered mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setResult(int, java.lang.String, android.os.Bundle)">setResult</A></B>(int&nbsp;code,
                   <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;data,
                   <A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A>&nbsp;extras)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change all of the result data returned from this broadcasts; only works
 with broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setResultCode(int)">setResultCode</A></B>(int&nbsp;code)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the current result code of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setResultData(java.lang.String)">setResultData</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the current result data of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../android/content/BroadcastReceiver.html#setResultExtras(android.os.Bundle)">setResultExtras</A></B>(<A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A>&nbsp;extras)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the current result extras of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BroadcastReceiver()"><!-- --></A><H3>
BroadcastReceiver</H3>
<PRE>
public <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.163"><B>BroadcastReceiver</B></A>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="onReceive(android.content.Context, android.content.Intent)"><!-- --></A><H3>
onReceive</H3>
<PRE>
public abstract void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.197"><B>onReceive</B></A>(<A HREF="../../android/content/Context.html" title="android.content 中的类">Context</A>&nbsp;context,
                               <A HREF="../../android/content/Intent.html" title="android.content 中的类">Intent</A>&nbsp;intent)</PRE>
<DL>
<DD>This method is called when the BroadcastReceiver is receiving an Intent
 broadcast.  During this time you can use the other methods on
 BroadcastReceiver to view/modify the current result values.  The function
 is normally called within the main thread of its process, so you should
 never perform long-running operations in it (there is a timeout of
 10 seconds that the system allows before considering the receiver to
 be blocked and a candidate to be killed). You cannot launch a popup dialog
 in your implementation of onReceive().
 
 <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag,
 then the object is no longer alive after returning from this
 function.</b>  This means you should not perform any operations that
 return a result to you asynchronously -- in particular, for interacting
 with services, you should use
 <A HREF="../../android/content/Context.html#startService(android.content.Intent)"><CODE>Context.startService(Intent)</CODE></A> instead of
 <A HREF="../../android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int)"><CODE>Context.bindService(Intent, ServiceConnection, int)</CODE></A>.  If you wish
 to interact with a service that is already running, you can use
 <A HREF="../../android/content/BroadcastReceiver.html#peekService(android.content.Context, android.content.Intent)"><CODE>peekService(android.content.Context, android.content.Intent)</CODE></A>.
 
 <p>The Intent filters used in <A HREF="../../android/content/Context.html#registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter)"><CODE>Context.registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter)</CODE></A>
 and in application manifests are <em>not</em> guaranteed to be exclusive. They
 are hints to the operating system about how to find suitable recipients. It is
 possible for senders to force delivery to specific recipients, bypassing filter
 resolution.  For this reason, <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive()</CODE></A>
 implementations should respond only to known actions, ignoring any unexpected
 Intents that they may receive.
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>context</CODE> - The Context in which the receiver is running.<DD><CODE>intent</CODE> - The Intent being received.</DL>
</DD>
</DL>
<HR>

<A NAME="peekService(android.content.Context, android.content.Intent)"><!-- --></A><H3>
peekService</H3>
<PRE>
public <A HREF="../../android/os/IBinder.html" title="android.os 中的接口">IBinder</A> <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.208"><B>peekService</B></A>(<A HREF="../../android/content/Context.html" title="android.content 中的类">Context</A>&nbsp;myContext,
                           <A HREF="../../android/content/Intent.html" title="android.content 中的类">Intent</A>&nbsp;service)</PRE>
<DL>
<DD>Provide a binder to an already-running service.  This method is synchronous
 and will not start the target service if it is not present, so it is safe
 to call from <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(android.content.Context, android.content.Intent)</CODE></A>.
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>myContext</CODE> - The Context that had been passed to <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(Context, Intent)</CODE></A><DD><CODE>service</CODE> - The Intent indicating the service you wish to use.  See <A HREF="../../android/content/Context.html#startService(android.content.Intent)"><CODE>Context.startService(Intent)</CODE></A> for more information.</DL>
</DD>
</DL>
<HR>

<A NAME="setResultCode(int)"><!-- --></A><H3>
setResultCode</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.236"><B>setResultCode</B></A>(int&nbsp;code)</PRE>
<DL>
<DD>Change the current result code of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.  Often uses the
 Activity <A HREF="../../android/app/Activity.html#RESULT_CANCELED"><CODE>Activity.RESULT_CANCELED</CODE></A> and
 <A HREF="../../android/app/Activity.html#RESULT_OK"><CODE>Activity.RESULT_OK</CODE></A> constants, though the
 actual meaning of this value is ultimately up to the broadcaster.
 
 <p><strong>This method does not work with non-ordered broadcasts such
 as those sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A></strong></p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>code</CODE> - The new result code.<DT><B>另请参见：</B><DD><A HREF="../../android/content/BroadcastReceiver.html#setResult(int, java.lang.String, android.os.Bundle)"><CODE>setResult(int, String, Bundle)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getResultCode()"><!-- --></A><H3>
getResultCode</H3>
<PRE>
public final int <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.246"><B>getResultCode</B></A>()</PRE>
<DL>
<DD>Retrieve the current result code, as set by the previous receiver.
<P>
<DD><DL>

<DT><B>返回：</B><DD>int The current result code.</DL>
</DD>
</DL>
<HR>

<A NAME="setResultData(java.lang.String)"><!-- --></A><H3>
setResultData</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.265"><B>setResultData</B></A>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;data)</PRE>
<DL>
<DD>Change the current result data of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.  This is an arbitrary
 string whose interpretation is up to the broadcaster.
 
 <p><strong>This method does not work with non-ordered broadcasts such
 as those sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A></strong></p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>data</CODE> - The new result data; may be null.<DT><B>另请参见：</B><DD><A HREF="../../android/content/BroadcastReceiver.html#setResult(int, java.lang.String, android.os.Bundle)"><CODE>setResult(int, String, Bundle)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getResultData()"><!-- --></A><H3>
getResultData</H3>
<PRE>
public final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.276"><B>getResultData</B></A>()</PRE>
<DL>
<DD>Retrieve the current result data, as set by the previous receiver.
 Often this is null.
<P>
<DD><DL>

<DT><B>返回：</B><DD>String The current result data; may be null.</DL>
</DD>
</DL>
<HR>

<A NAME="setResultExtras(android.os.Bundle)"><!-- --></A><H3>
setResultExtras</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.297"><B>setResultExtras</B></A>(<A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A>&nbsp;extras)</PRE>
<DL>
<DD>Change the current result extras of this broadcast; only works with
 broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.  This is a Bundle
 holding arbitrary data, whose interpretation is up to the
 broadcaster.  Can be set to null.  Calling this method completely
 replaces the current map (if any).
 
 <p><strong>This method does not work with non-ordered broadcasts such
 as those sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A></strong></p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>extras</CODE> - The new extra data map; may be null.<DT><B>另请参见：</B><DD><A HREF="../../android/content/BroadcastReceiver.html#setResult(int, java.lang.String, android.os.Bundle)"><CODE>setResult(int, String, Bundle)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getResultExtras(boolean)"><!-- --></A><H3>
getResultExtras</H3>
<PRE>
public final <A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A> <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.313"><B>getResultExtras</B></A>(boolean&nbsp;makeMap)</PRE>
<DL>
<DD>Retrieve the current result extra data, as set by the previous receiver.
 Any changes you make to the returned Map will be propagated to the next
 receiver.
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>makeMap</CODE> - If true then a new empty Map will be made for you if the
                current Map is null; if false you should be prepared to
                receive a null Map.
<DT><B>返回：</B><DD>Map The current extras map.</DL>
</DD>
</DL>
<HR>

<A NAME="setResult(int, java.lang.String, android.os.Bundle)"><!-- --></A><H3>
setResult</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.342"><B>setResult</B></A>(int&nbsp;code,
                            <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;data,
                            <A HREF="../../android/os/Bundle.html" title="android.os 中的类">Bundle</A>&nbsp;extras)</PRE>
<DL>
<DD>Change all of the result data returned from this broadcasts; only works
 with broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.  All current result data is replaced
 by the value given to this method.
 
 <p><strong>This method does not work with non-ordered broadcasts such
 as those sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A></strong></p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>code</CODE> - The new result code.  Often uses the
 Activity <A HREF="../../android/app/Activity.html#RESULT_CANCELED"><CODE>Activity.RESULT_CANCELED</CODE></A> and
 <A HREF="../../android/app/Activity.html#RESULT_OK"><CODE>Activity.RESULT_OK</CODE></A> constants, though the
 actual meaning of this value is ultimately up to the broadcaster.<DD><CODE>data</CODE> - The new result data.  This is an arbitrary
 string whose interpretation is up to the broadcaster; may be null.<DD><CODE>extras</CODE> - The new extra data map.  This is a Bundle
 holding arbitrary data, whose interpretation is up to the
 broadcaster.  Can be set to null.  This completely
 replaces the current map (if any).</DL>
</DD>
</DL>
<HR>

<A NAME="getAbortBroadcast()"><!-- --></A><H3>
getAbortBroadcast</H3>
<PRE>
public final boolean <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.355"><B>getAbortBroadcast</B></A>()</PRE>
<DL>
<DD>Returns the flag indicating whether or not this receiver should
 abort the current broadcast.
<P>
<DD><DL>

<DT><B>返回：</B><DD>True if the broadcast should be aborted.</DL>
</DD>
</DL>
<HR>

<A NAME="abortBroadcast()"><!-- --></A><H3>
abortBroadcast</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.373"><B>abortBroadcast</B></A>()</PRE>
<DL>
<DD>Sets the flag indicating that this receiver should abort the
 current broadcast; only works with broadcasts sent through
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A>.  This will prevent
 any other broadcast receivers from receiving the broadcast. It will still
 call <A HREF="../../android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)"><CODE>onReceive(android.content.Context, android.content.Intent)</CODE></A> of the BroadcastReceiver that the caller of 
 <A HREF="../../android/content/Context.html#sendOrderedBroadcast(android.content.Intent, java.lang.String)"><CODE>Context.sendOrderedBroadcast</CODE></A> passed in.
 
 <p><strong>This method does not work with non-ordered broadcasts such
 as those sent with <A HREF="../../android/content/Context.html#sendBroadcast(android.content.Intent)"><CODE>Context.sendBroadcast</CODE></A></strong></p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearAbortBroadcast()"><!-- --></A><H3>
clearAbortBroadcast</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.382"><B>clearAbortBroadcast</B></A>()</PRE>
<DL>
<DD>Clears the flag indicating that this receiver should abort the current
 broadcast.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOrderedHint(boolean)"><!-- --></A><H3>
setOrderedHint</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.390"><B>setOrderedHint</B></A>(boolean&nbsp;isOrdered)</PRE>
<DL>
<DD>For internal use, sets the hint about whether this BroadcastReceiver is
 running in ordered mode.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDebugUnregister(boolean)"><!-- --></A><H3>
setDebugUnregister</H3>
<PRE>
public final void <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.405"><B>setDebugUnregister</B></A>(boolean&nbsp;debug)</PRE>
<DL>
<DD>Control inclusion of debugging help for mismatched
 calls to .
 If called with true, before given to registerReceiver(), then the
 callstack of the following <A HREF="../../android/content/Context.html#unregisterReceiver(android.content.BroadcastReceiver)"><CODE>Context.unregisterReceiver()</CODE></A> call is retained, to be printed if a later
 incorrect unregister call is made.  Note that doing this requires retaining
 information about the BroadcastReceiver for the lifetime of the app,
 resulting in a leak -- this should only be used for debugging.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDebugUnregister()"><!-- --></A><H3>
getDebugUnregister</H3>
<PRE>
public final boolean <A HREF="../../src-html/android/content/BroadcastReceiver.html#line.412"><B>getDebugUnregister</B></A>()</PRE>
<DL>
<DD>Return the last value given to <A HREF="../../android/content/BroadcastReceiver.html#setDebugUnregister(boolean)"><CODE>setDebugUnregister(boolean)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BroadcastReceiver.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../android/content/AsyncQueryHandler.html" title="android.content 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../android/content/ComponentCallbacks.html" title="android.content 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?android/content/BroadcastReceiver.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="BroadcastReceiver.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
